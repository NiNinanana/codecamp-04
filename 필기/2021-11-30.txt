오늘의 커리큘럼
로그인 프로세스 -> 인증테이블 파티셔닝 -> JWT토큰 -> 로그인과 context-api

부담없이~~~~

메모리 세션
br에서 b에 아이디와 비번을 보내고 그걸 b에서 세션으로 저장
그런데 메모리는 계속 쌓여져 가기에 용량이 부족해진다.
스케일 업(scale up)을 통해 메모리와 cpu를 증가시켜 준다.

stateful
그렇다고 백엔드 컴퓨터를 여러개 만들어서 용량을 늘리게 되면
1번째 컴퓨터에 로그인을 해서 메모리가 쌓였을 지라도 2번째 컴퓨터로 메모리가 들어가게 되면 안할거로 처리가 되버린다

stateless
세션을 db로 빼고 어디 백엔드 컴퓨터로 접속하던지 상관이 없게 된다.
그러나 이번에는 db에 병목현상이 일어나게 된다.

파티셔닝
테이블을 나눈다
수직으로
수직파티셔닝 <-> 수평 파티셔닝

번호, 이메일, 이름을 User에
돈, 계좌를 UserPayment에

수평파티셔닝 => db 샤딩
번호 1~1000 / 1001~2000/ ~~~
하나씩을 db1, db2 처럼 분리를 한다
대용량 트래픽을 수용할 수 있게 됨

RoundRobin
백엔드 하나씩 돌아가면서 접속하게 하는 것

Redis

db를 긁는다
db에서 데이터를 가져오는 것

JWT토큰
db를 안긁어도 되게끔

token
로그인을 하고 b에서 db에 넘겼을 때 주는 id
그리고 그 토큰을 b로 b에서 br로
br에서 myToken <= id 저장

local 저장소
state
cookie
localStorage
sessionStorage

br에서 createProduct를 할려고 할 때 
name, price 등등도 보내야 하지만
myToken도 넘겨야 한다
b에서는 db에 가서 myToken에 해당하는 것을 찾아서 로그인이 되어있는지 확인

JWT(JSON Web Token)
토큰을 객체로 바꾸고 다시 객체를 토큰으로 바꾸고

암호화
글자에 해당하는 알파벳으로 바꾸고

복호화
그 알파벳을 다시 글자로 바꾸고

{
    이름: 철수
    로그인기간: 2021.11.30까지
}

--->

알수없는문자
// JWT

JWT사용 시
br에서 createProduct를 할려고 할 때 
name, price 등등도 보내야 하지만
myToken도 넘기고
b에서 스스로 복호화
그러고 바로 db에 등록

token에 대한 보안적 위험이 있다
JWT 만료시간: 30분~2시간(backend04는 1시간)

db긁는 거
최초 1회만 기록하고 재발급시에만 

createProduct 할 때
accessToken을 어떻게 보내야 하는가


authorization해서 헤더부분에 accessToken을 넣는다

graphql에서는 아래 http headers 부분에다가
{
    "authorization": "토큰넣기"
}

Bearer 토큰 인증
위 토큰 넣기에 "Bearer 토큰"라고 넣기도 한다(관례)

jwt.io에서 토큰을 붙여넣으면 안 내용이 다 보인다
그렇기에 중요한 내용은 넣지 말자
그럼에도 수정은 불가능하다
키가 토큰에 다 들어가게 되는데 그 키가 조작되어있는지 검증하는 것이다.

비번은 보안쪽에서 되게 중요하다
따라서 암호화르ㅡㄹ 시켜서 저장해야 한다
br에서 1234로 비밀번호를 저장하면 b에서 암호화해서 db에 저장한다

암호화
    1. 양방향 암호화
        1234 -> abcd 암호화 / abcd -> 1234 복호화
    2. 단방향 암호화(password hash)
        1234 -> 24 암호화 / 1535 -> 24 암호화 ...
        복호화하기 어렵다.








